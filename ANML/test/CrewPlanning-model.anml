/*
 * @author Javier Barreiro
 * @brief Crew Planning model for SAVH demo. translation from NDDL into ANML
 */
 
// Time unit is minutes throughout the model

vartype PositiveInt       : int [0 +inf];
vartype TDRS              : PositiveInt; // Communication Channels
vartype ExerciseEquipment : PositiveInt; 
vartype PRACapacity       : PositiveInt; // Max number of Physically Restraining activities  

vartype ProcessState : enum {"in_progress","finished"};
vartype FilterState  : enum {"changing","changed"};
vartype FastingState : enum {"fasting","not_fasting"}; 


/* 
 * Class and actions to keep track of fasting window
 * this would be better handled through a state constraint        
 */
objtype FastingWindow
{
    FastingState state_;
      
    action not_fasting() {
        change over all { transition state_  { "fasting" -> {"not_fasting","fasting"} } };
    }
}
 
// TODO: if we put it inside CrewMember, does that mean we have to specify a CrewMember when we set up a goal?
predicate payload_act_completed(        
    int id,
    string desc,
    int length,
    int priority, 
    int dueDate,
    int usesComms,
    int isPhysicallyRestraining);
    
objtype CrewMember
{
    FastingWindow fw_;
    ProcessState mcs_;  // Medical Conference state
    
    // TODO: added constraints to the grammar for actions, is that correct?         
    action pre_sleep() { 
        duration 120;    
        condition over all { fw_.state_ = "not_fasting" }; 
    }
    
    action sleep() { 
        duration 480;    
    }
    
    action post_sleep() { 
        duration 180;    
        condition over all { fw_.state_ = "not_fasting" }; 
    }
    
    action dpc() { 
        duration 15;    
    }
    
    action meal() { 
        duration 60;    
        condition over all { fw_.state_ = "not_fasting" };
        
        // keep separation between meals >= 4 hrs
        condition over [start-240 start] { fw_.state_ = "fasting" };  
        condition over [end end+240] { fw_.state_ = "fasting" };  
    }
    
    action exercise() { 
        duration 60;    

        // Can't excercise within an hour of finishing a meal
        condition over [start-60 start] { fw_.state_ = "fasting" };
        change over all { uses(ExerciseEquipment,1) }; // TODO: how do we say "use one of the available pieces of equipment"?
    } 
    
    action change_filter(FilterState fs) {         
        duration 60;    
        
        change over all { transition fs { "changed" -> {"changing","changed"} } };
        
        // make sure next filter change happens within the next 24 to 48 hours
        effect in [end+1440 end+2880] { fs = "changing" };
    }    
    
    action medical_conference() { 
        duration 60;    
        change over all { transition mcs_ { "finished" -> {"in_progress","finished"} } };
        
        // make sure next medical conference happens within the next 24 to 48 hours
        effect in [end+1440 end+2880] { mcs_ = "in_progress" };
    }

  
    action payload_activity (
        int id,
        string desc,
        int length,
        int priority, 
        int dueDate,
        int usesComms,
        TDRS comms,
        int isPhysicallyRestraining,
        PRACapacity praCapacity) {
        
        duration length;    
        // TODO: only relational operator currently allowed in the grammar is =
        // TODO: condition start >= 0; // Is this still necessary to force into planning window? 
        // TODO: condition end <= dueDate;
                
        // TODO: accourding to the grammar this is invalid since uses can only be used as part of a change stmt
        effect when { usesComms = 1 } { uses(comms,1) };
        effect when { isPhysicallyRestraining = 1 }  { uses(praCapacity,1) };
        
        effect at end { payload_act_completed(id,desc,length,priority,dueDate,usesComms,isPhysicallyRestraining) };
    }
    
    // RPCM R&R Actions
    action remove_sleep_station() { 
        duration 60;    
    }
    
    action reconfigure_thermal_loops(int loopCnt)
    {  
        duration 60;    
    }
    
    action remove_power_source() { 
        duration 60;    
    }
    
    action replace_rpcm() { 
        duration 60;    
    }
    
    action place_power_source() { 
        duration 60;    
    }
    
    action assemble_sleep_station() { 
        duration 60;    
    }        
}

objtype CrewPlanner
{
    CrewMember crewMember_;    
    ProcessState state_;
    
    action daily_routine() {
        duration 1440;    

        change over all { transition state_ { "finished" -> {"in_progress","finished"} } };
        
        // setup the next daily routine
        effect at end+1 { state_ = "in_progress" };          

        decomposition {
            crewMember_.pre_sleep pre_sleep;
            crewMember_.sleep sleep;
            crewMember_.post_sleep post_sleep;
            crewMember_.dpc dpc;
            crewMember_.meal meal;
            crewMember_.exercise exercise;
            
            // Precedence relationships
            eq(post_sleep.end,dpc.start);
            eq(pre_sleep.end,sleep.start);
            
            // Start the day with post_sleep and finish with sleep
            eq(start,post_sleep.start);
            eq(end,sleep.end);    
        }        
    }
}

objtype RPCM
{
    ProcessState state_;
    
    action perform() {
        // I want any CrewMember to perform any activity, is CrewMember.* the intended ANML syntax?
        change over all { transition state_ { "finished" -> { "in_progress" -> "finished" } } };
        
        // TODO: added constraints to the grammar for decompositions, is that correct?         
        decomposition {
		    CrewMember.remove_sleep_station() step1;
		    CrewMember.remove_power_source() step2;
		    lt(step1.end,step2.start);
		    
		    // Reconfigure thermal loops as single loop
		    CrewMember.reconfigure_thermal_loops(1) step3;
		        
		    CrewMember.replace_rpcm() step4;
		    lt(step2.end,step4.start);
		    lt(step3.end,step4.start);
		    
		    CrewMember.place_power_source() step5;
		    CrewMember.assemble_sleep_station() step6;
		    lt(step4.end,step5.start);
		    lt(step5.end,step6.start);
		    
		    // Reconfigure thermal loops as redundant loops
		    CrewMember.reconfigure_thermal_loops(2) step7;
		    lt(step4.end,step7.start);
        }
    }            
}
 