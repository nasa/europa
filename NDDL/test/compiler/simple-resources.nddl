class Resource {
 // Specified resource properties
 int horizonStart;
 int horizonEnd;
 float initialCapacity;
 float level_limit_max;
 float level_limit_min;

 // The only predicate we allow
 predicate change{
  float quantity;
 }

 Resource(int hs, int he, float ic, float ll_min, float ll_max){
  horizonStart = hs;
  horizonEnd = he;
  initialCapacity = ic;
  level_limit_min = ll_min;
  level_limit_max = ll_max;
 }

 Resource(){}
}

class Battery extends Resource {}

class SolarPanel extends Resource {}

enum Locations {Here, There, Everywhere};

class Rover {
 predicate Drive{
  Locations from, to;
  float expected_energy_used;
 }
}

Rover::Drive{
 neq(from, to);
 meets(Battery.change battery);

 // Compiler BUG not to trap error on name usage
 eq(battery.quantity, expected_fuel_used);
}

class World{
 SolarPanel solarPanel;
 Battery mainBattery;
 Battery reserveBattery;
 Rover rover;

 predicate initialState{}

 World(){
  solarPanel = new SolarPanel(0, 100, 10, 0, 30);
  mainBattery = new Battery(0, 100, 1000, 100, 1200);
  reserveBattery = new Battery(0, 100, 1000, 100, 1200);
  rover = new Rover();
 }
}

World::initialState{
 // First drive
 any(Rover.Drive a);
 eq(a.from, Here);
 eq(a.to, There);

 // Second drive occurs later
 any(Rover.Drive b);
 eq(b.from, There);
 eq(b.to, Everywhere);

 // First drive first!
 leq(a.end, b.start);

 any(Battery.change tx);
 eq(tx.quantity, 4);
}
