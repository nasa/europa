enum Locations {Hill, Rock, Lander};

class Rover{
 predicate At{
  Locations _location;
 }

 predicate Going{
  Locations _from, _to;
 }
}

Rover::At{
 meets(object.Going to);
 eq(to._from, _location);

 meets(Going from);
 eq(from._to, _location);
}

Rover::Going{
 neq(_from, _to);
}

// Defines the initial state for the problem.
class World {
 // Horizon information
 int m_horizonStart;
 int m_horizonEnd;
 Rover rover;

 predicate initialState{}
 World(){
  // Set up the planning horizon
  m_horizonStart = 0;
  m_horizonEnd = 200;
  rover = new Rover();
 }
}

World::initialState{
 // Enforce horizon bounds on initialState
 leq(object.m_horizonStart, start);
 leq(end, object.m_horizonEnd);
 
 contains(Rover.At a);
 eq(a._location, "Lander");

 contains(Rover.At b);
 eq(b._location, Rock);

 leq(a.end, b.start);

 // Test rule to use local variables
 Rover r1;
 Rover r2;
 eq(r1, r2);

 // Test use of binary temporal relation
 b after (Rover.At c);
 a meets c;
}