package nddl;

import net.n3.nanoxml.*;
import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.io.FileNotFoundException;

/**
 * @brief Integrates all access to the XML structure in a common place
 * and returns the information for substitution into code by the caller.
 */
public class ModelAccessor {
  static String s_plasmaHome = NddlUtil.getenv("PLASMA_HOME");
  static String s_directory = System.getProperty("user.dir");
  static final String DEFAULT_CFG = "NDDL.cfg";
  static String s_cfgFilename = DEFAULT_CFG;
  static boolean s_cfgExact = true;

  // Holds all classes as they are visited
  private static Map s_classesByName = new HashMap();

  // Holds the full set of ancestors for a class, accessed by name
  private static Map s_childOf = new Hashtable();

  // The model name, derived from input file name
  private static String s_modelName = new String("NO_MODEL");

  // Contains the set of all
  private static Map s_predicatesByName = new Hashtable();

  // Maps variable names to their types
  private static Map s_varTypesByName = new HashMap();

  // Maps slave names to their predicate types
  private static Set s_slaves = new HashSet();

  // Maps variable names to their default base domains
  private static Map s_defaultDomainsByName = new HashMap();

  // Holds all enumerations as they are declared
  static private Map s_allEnumerations = new HashMap();

  // Holds information as to which "enumerations" are intervals
  static private Set s_intervals = new HashSet();

  // Current Object Type
  static private String s_currentObjectType = "";

  // Current Predicate
  static private String s_currentPredicate = "";

  // Stack for nested rule contexts
  static private Stack s_currentRule = new Stack();

  // Search path for nddl include files.
  static private List s_customSearchPath = new ArrayList();

  /**
   * @brief Lists the currently supported temporal relations
   * @see NddlUtils macros
   */
  public static final Set s_slave_relations = NddlUtil.immutableSet(new String[]{
    "any", "meets", "met_by", "contains", "contained_by", "before", "after", "starts", "ends",
    "ends_after", "ends_before", "ends_after_start", "starts_before_end", "starts_during",
    "contains_start", "ends_during", "contains_end", "starts_after", "starts_before", "equal", "equals"});

  /**
   * @brief Lists the built in variables assumed by all tokens, and referenced in rules
   * @see Token.hh
   */
  public static final Set s_reserved_variables = NddlUtil.immutableSet(new String[]{"start", "end", "duration", "object", "state"});

  /**
   * Enumerates rule nodes in XML that can intorduce guards
   */
  private static final Set s_guardableNodes = NddlUtil.immutableSet(new String[]{"if", "invoke", "subgoal"});

  private static final Set s_singletonGuardNames = NddlUtil.immutableSet(new String[]{"ident", "id"});

  /**
   * Defines a binding to pre-existing C++ classes for classes generated by the
   * compiler. This is how customizations in the framework can be integrated to
   * add domain specifica semantic extensions to the NDDL framework.
   */
  private static Map s_customClassesByNddlName = new HashMap();

  /**
   * A set containing all additional include files to include in the generated
   * header file. Derived from same input configuration file as the custom
   * class bindings.
   */
  private static Set s_customIncludes = new HashSet();

  private static Set s_usedCustomIncludes = new HashSet();

  private static Map s_customIncludesByCppName = new HashMap();

  public static void changeDirectory(String toDir) {
    if(toDir.equals(""))
      s_directory = System.getProperty("user.dir");
    else if(new File(toDir).isAbsolute())
      s_directory = toDir;
    else
      s_directory = new File(s_directory, toDir).toString();
    File debugCfg = new File(s_directory, "Debug.cfg");
    try {
      DebugMsg.reset();
      if(debugCfg.canRead())
        DebugMsg.loadFile(s_directory + File.separator + "Debug.cfg");
    }
    catch(Exception ex) {}
  }

  public static void setConfigFile(String filename) {
    if(filename == null || filename.equals(""))
      s_cfgFilename = DEFAULT_CFG;
    else
      s_cfgFilename = filename;
  }

  /** MODEL ACCESS **/
  public static void setModelName(String modelName) {
    s_modelName = modelName;
  }

  public static String getModelName() {
    return s_modelName;
  }

  /** CLASS ACCESSORS **/

  public static String getClassName(IXMLElement element) {
    String className = "";

    if(isPredicate(element))
      className = XMLUtil.getAttribute(element,"predicate", "name");
    else
      className = XMLUtil.getAttribute(element,"class", "name");

    if(!isClass(className))
      addClassByName(className, element);

    assert(DebugMsg.debugMsg("ModelAccessor","ModelAccessor::getClassName - " + className));
    return className;
  }

  public static void addSearchPath(String path) {
    assert(DebugMsg.debugMsg("ModelAccessor:addSearchPath", "Adding search path " + path));
    s_customSearchPath.add(path);
  }

  public static String getSuperClass(IXMLElement element) {
    if(isPredicate(element))
      return getPredicateSuperClass(element);
    else
      return getParentClassName(element);
  }

  public static String getCppClass(String nddlClass) {
    String cppClass = nddlClass;
    if(isPredefinedClass(nddlClass)) {
      cppClass = (String) s_customClassesByNddlName.get(nddlClass);
      assert(DebugMsg.debugMsg("ModelAccessor:getCppClass",
                               "Nddl class '" + nddlClass + "' is a pre-defined class.  The " +
                               " C++ class is '" + cppClass + "'."));
      if(s_customIncludesByCppName.containsKey(cppClass)) {
        s_usedCustomIncludes.add(s_customIncludesByCppName.get(cppClass));
        assert(DebugMsg.debugMsg("ModelAccessor:getCppClass",
                                 "C++ class '" + cppClass + "' requires header '" +
                                 s_customIncludesByCppName.get(cppClass).toString() + "'"));
      }
    }
    assert(DebugMsg.debugMsg("ModelAccessor:getCppClass",nddlClass + " becomes " + cppClass));
    return cppClass;
  }

  public static String getQualifiedClassName(IXMLElement element) {
    return XMLUtil.qualifiedName(element);
  }

  /**
   * @brief Handles the mapping to include the built in or implicit classes
   */
  public static String getParentClassName(IXMLElement element) {
    XMLUtil.checkExpectedNode("class", element);

    String className = getClassName(element);

    String klass = null;

    if(element.hasAttribute("extends")) // Not a root class so just return logical class
      klass = XMLUtil.getAttribute(element,"class", "extends");
    else if(s_customClassesByNddlName.get(className) != null) // Lookup custom registrations first
      klass = "Object";

    // This is in error as of parser version 1.1.  Fear the worst now that this is fixed!
    //else if(element.getFirstChildNamed("predicate") != null) // Backward compatibility - Predicates imply a Timeline
    //klass = "Timeline";

    else
      klass = "Object"; // Otherwise it is an object. Saves explicit declaration of base class

    assert(DebugMsg.debugMsg("ModelAccessor:getParentClassName",className + " extends " + klass));
    return klass;
  }

  public static boolean isClass(String elementName) {
    return s_classesByName.get(elementName) != null;
  }

  public static boolean isObjectType(IXMLElement element) {
    return element.getName().equals("class");
  }

  /**
   * Tests if the given string is matched with special built in classes, as opposed to simply being
   * a new class defined in the model.
   */
  public static boolean isPredefinedClass(String className) {
    return s_customClassesByNddlName.containsKey(className);
  }

  /** PREDICATE ACCESSORS **/

  /**
   * Register a predicate
   */
  public static void registerPredicate(IXMLElement predicate) {
    String name = XMLUtil.getAttribute(predicate,"name");
    String scope = XMLUtil.getAttribute(predicate.getParent(), "name");
    s_predicatesByName.put(scope + "." + name, predicate);
  }

  /**
   * @brief Obtain the class for which this predicate is defined
   */
  public static String getPredicateClassName(IXMLElement element) {
    return getClassName(element.getParent());
  }

  /**
   * @brief Obtain the name of the predicate
   */
  public static String getPredicateName(IXMLElement element) {
    return XMLUtil.getAttribute(element,"predicate", "name");
  }

  public static boolean isPredicate(String name) {
    return s_predicatesByName.containsKey(name);
  }

  public static boolean isPredicate(IXMLElement element) {
    return element.getName().equals("predicate");
  }

  public static String getPredicateSuperClass(IXMLElement predicate) {
    String toRet = getPredicateSuperClass(predicate,true);
    assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search","-> returning "+toRet));
    return toRet;
  }

  public static String getPredicateSuperClass(IXMLElement predicate, boolean dummy) {
    String name = XMLUtil.getAttribute(predicate, "name");
    String klass = XMLUtil.getAttribute(predicate.getParent(), "name");

    // first, try most specific custom binding: class.name
    String scopedName = klass + "." + name;
    assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search",scopedName));

    if(s_customClassesByNddlName.get(scopedName) != null)
      return (String) s_customClassesByNddlName.get(scopedName);

    // second, the more general case of: class.*
    scopedName = klass + ".*";
    assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search",scopedName));

    if(s_customClassesByNddlName.get(scopedName) != null)
      return (String) s_customClassesByNddlName.get(scopedName);

    // Try ancestors
    List ancestors = getAncestors(klass);
    if(ancestors != null) {
      assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search","Ancestors: "+ancestors));
      // ancestors are listed fifo (this should have been causing problems earlier)
      for(int i=ancestors.size()-1; i>=0; --i) {
        String ancestor = (String) ancestors.get(i);
        // third, check for specific parent predicates: ancestor.name
        String superPredicate = ancestor + "." + name;
        assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search",superPredicate));

        if(isPredefinedClass(superPredicate))
          return getCppClass(superPredicate);
        else if(isPredicate(superPredicate))
          return ancestor + "::" + name;

        // fourth, check for general parent predicates: ancestor.*
        superPredicate = ancestor + ".*";
        assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search",superPredicate));
        if(isPredefinedClass(superPredicate))
          return getCppClass(superPredicate);
      }
    }

    // Otherwise we simply return the standard predicate cpp class
    assert(DebugMsg.debugMsg("ModelAccessor:getPredicateSuperClass:Search","NddlToken"));
    return "NddlToken";
  }

  public static IXMLElement getPredicate(String name) {
    IXMLElement predicate = null;
    if(isPredicate(name))
      predicate = (IXMLElement) s_predicatesByName.get(name);
    return predicate;
  }

  /** VARIABLE ACCESSORS **/

  public static boolean isMemberVariable(String klassName, String varName) {
    assert(DebugMsg.debugMsg("ModelAccessor","isMemberVariable:" + klassName + "." + varName));

    if(s_varTypesByName.get(klassName + "." + varName) != null)
      return true;

    List ancestors = getAncestors(klassName);

    for(int i=0; i < ancestors.size(); ++i) {
      String currentClass = (String) ancestors.get(i);
      if(s_varTypesByName.get(currentClass + "." + varName) != null)
        return true;
    }

    return false;
  }

  /**
   * Obtain the C++ type for a <var> element
   */
  public static String getVariableType(IXMLElement element) {
    return XMLUtil.getAttribute(element, "type");
  }

  public static String getVariableName(IXMLElement element) {
    return XMLUtil.getAttribute(element, "name");
  }

  public static boolean guardedBySingleton(IXMLElement guardCondition) {
    return s_singletonGuardNames.contains(guardCondition.getName());
  }

  /** MEMBERS FOR INTERNAL DATA MANAGEMENT **/
  private static void addClassByName(String className, IXMLElement element) {
    s_classesByName.put(className, element);
  }

  /** MEMBERS FOR MANAGING OVERALL SCOPE **/
  public static void setCurrentObjectType(String name) {
    s_currentObjectType = name;
  }
  public static void resetCurrentObjectType() {
    s_currentObjectType = "";
  }
  public static void setCurrentPredicate(String name) {
    s_currentPredicate = name;
  }
  public static void resetCurrentPredicate() {
    s_currentPredicate = "";
  }
  public static void setCurrentRule(String name) {
    String priorRules = "";

    for(int i=0; i < s_currentRule.size(); ++i)
      priorRules = priorRules + "=>" + s_currentRule.elementAt(i);
    assert(DebugMsg.debugMsg("ModelAccessor:setCurrentRule","Prior rules" + priorRules));

    s_currentRule.push(name);
  }
  public static void resetCurrentRule() {
    String name = (String) s_currentRule.pop();
    assert(DebugMsg.debugMsg("ModelAccessor:resetCurrentRule","Removing " + name));
  }
  public static String getCurrentObjectType() {
    return s_currentObjectType;
  }
  public static String getCurrentPredicate() {
    return s_currentPredicate;
  }
  public static String getPredicateScope() {
    if(s_currentObjectType.equals("") || s_currentPredicate.equals(""))
      return "!ERROR";

    return s_currentObjectType + "." + s_currentPredicate;
  }
  public static String getCurrentScope() {
    if(!s_currentRule.empty())
      return (String) s_currentRule.peek();

    if(!s_currentPredicate.equals(""))
      return s_currentObjectType + "." + s_currentPredicate;

    return s_currentObjectType;
  }

  /**
   * Log this so we can use it to test for inheritance relationships.
   */
  public static void addParentChildRelation(String parent, String child) {
    List parentAncestors = null;
    if(s_childOf.containsKey(parent))
      parentAncestors = (List) s_childOf.get(parent);
    else
      parentAncestors = new ArrayList();

    List childAncestors = new ArrayList(parentAncestors);
    childAncestors.add(parent);
    s_childOf.put(child, childAncestors);
  }

  public static void addEnumMember(String enumName, String enumMember) {
    String enumType = (String)s_allEnumerations.get(enumName);
    s_allEnumerations.put(enumName + "." + enumMember,enumType);
    s_allEnumerations.put(enumMember,enumType);
  }

  /**
   * Retrieve the ancestors for a klass
   */
  public static List getAncestors(String klass) {
    return (List) s_childOf.get(klass);
  }

  /**
   * Variable declarations can appear in a number of guises:
   * 1. Predicate Parameters
   * 2. Class Variables
   * 3. Local Rule Variables
   *
   * This function will allocate the domain type to be later retrieved by name
   * @param variable The <var> xml element
   */
  public static void registerVariable(IXMLElement variable) {
    String varType = getVariableType(variable);
    String varName = getVariableName(variable);
    String parentType = getCurrentScope();
    String qualifiedName = getQualifiedName(variable);
    s_varTypesByName.put(qualifiedName, varType);

    // fix for typedefs to ensure that runtime typechecking does not fail
    if(isEnumeration(varType))
      varType = (String)s_allEnumerations.get(varType);

    // If the current scope is not a rule, then register this in the schema
    if(s_currentRule.empty())
      SchemaWriter.addCommand("addMember(\""+parentType+"\", \""+varType+"\", \""+varName+"\")");

    assert(DebugMsg.debugMsg("ModelAccessor:registerVariable",qualifiedName + " of type " + varType));

    String defaultBaseDomain = "";

    if(variable.getChildren().size() == 1) // Then it has a default value assigned
      defaultBaseDomain = makeDomainFromConstant(variable.getChildAtIndex(0));
    else
      defaultBaseDomain = makeDomain(variable);

    s_defaultDomainsByName.put(qualifiedName, defaultBaseDomain);
  }

  /**
   * Registers the default domain string for a givem memberName.
   * @param variable The <var> xml element
   * @see getDefaultDomain
   */
  static private void registerDefaultDomain(IXMLElement variable) {
    XMLUtil.checkExpectedNode("var", variable);
  }

  public static String getTypeForScopedVariable(String qualifiedName) {
    String result = (String) s_varTypesByName.get(qualifiedName);
    assert(DebugMsg.debugMsg("ModelAccessor","ModelAccessor.getTypeForScopedVariable TYPE for " + qualifiedName + " is " + result));;
    return result;
  }

  public static String getQualifiedName(IXMLElement variable) {
    String var_name = XMLUtil.nameOf(variable);
    return getCurrentScope() + "." + var_name;
  }

  /**
   * Class, Predicate or Compat
   */
  public static String getVariableParentType(IXMLElement variable) {
    IXMLElement parent = variable.getParent();


    while (parent != null) {
      if(parent.getName().equals("compat"))
        return XMLUtil.getAttribute(parent, "class") + "." + XMLUtil.getAttribute(parent, "name");
      else if(parent.getName().equals("predicate")) {
        String suffix = XMLUtil.getAttribute(parent, "name");
        String prefix = XMLUtil.getAttribute(parent.getParent(), "name");
        return prefix + "." + suffix;
      }
      else if(parent.getName().equals("class"))
        return XMLUtil.getAttribute(parent, "name");
      else
        parent = parent.getParent();
    }

    return "!ERROR";
  }

  /**
   * Retrives the default initial domain for a member variable of
   * a predicate or a class.
   * @param variable The <var> XMLElement
   * @see makeDomainFromConstant, registerDefaultDomain
   */
  public static String getDefaultDomain(IXMLElement variable) {
    XMLUtil.checkExpectedNode("var", variable);
    String memberName = getQualifiedName(variable);
    String defaultDomain = (String) s_defaultDomainsByName.get(memberName);
    assert(DebugMsg.debugMsg("ModelAccessor:getDefaultDomain","Default domain for " + memberName + " is " + defaultDomain));
    return defaultDomain;
  }

  /**
   * Constructs the domain from a <var> xmlElement
   * @see getDomain(String vartType)
   */
  public static String getDomain(IXMLElement variable) {
    XMLUtil.checkExpectedNode("var", variable);
    String var_type = XMLUtil.typeOf(variable);
    IXMLElement scope = variable.getParent();
    IXMLElement type = null;
    while (scope != null) {
      for (Enumeration e = scope.getChildren().elements() ; e.hasMoreElements() ; ) {
        IXMLElement type_element = (IXMLElement)e.nextElement();
        if(!type_element.hasAttribute("name")) {
          continue;
        }
        if(var_type.equals(XMLUtil.nameOf(type_element))) {
          type = type_element;
          break;
        }
      }
      scope = scope.getParent();
    }
    if(type != null) {
      var_type = XMLUtil.qualifiedName(type);
    }

    return(getDomain(var_type));
  }

  /**
   * Retrieves the domain class name given the domain type
   * @param type The type of the domain
   */
  public static String getDomain(String type) {
    String domainName = "";
    if(type.equals(NddlXmlStrings.x_boolean)) {
      domainName = "BoolDomain";
    }
    else if(type.equals(NddlXmlStrings.x_int)) {
      domainName = "IntervalIntDomain";
    }
    else if(type.equals(NddlXmlStrings.x_float)) {
      domainName = "IntervalDomain";
    }
    else if(type.equals(NddlXmlStrings.x_string)) {
      domainName = "StringDomain";
    }
    else if(type.equals(NddlXmlStrings.x_symbol)) {
      domainName = "SymbolDomain";
    }
    else if(isEnumeration(type)) {
      domainName = type;
    }
    else domainName = type + "Domain";

    // @todo Still have to handle Id's!
    return domainName;
  }

  public static String makeDomain(IXMLElement variable) {
    String longname = getQualifiedClassName(variable.getParent());
    String var_type = getVariableType(variable);
    String baseDomain = "StringDomain(\"string\")";
    if(isClass(var_type)) { // It must be an object variable for a predicate
      baseDomain =  "ObjectDomain(\""+var_type+"\")";
    }
    else if(isEnumeration(longname + "::" + var_type)) {
      baseDomain =  longname + "::" + var_type + "BaseDomain()";
    }
    else if(isEnumeration(var_type)) {
      baseDomain =  var_type + "BaseDomain()";
    }
    else if(!var_type.equals("string")) {
      baseDomain = ModelAccessor.getDomain(var_type) + "(\""+var_type+"\")";
    }
    return baseDomain;
  }
  /**
   * Will generate code to construct a domain for a constant
   */
  public static String makeDomainFromConstant(IXMLElement argument) {
    String arg_type = argument.getName();
    if(argument.getName().equals("value"))
      arg_type = argument.getAttribute("type", "ERROR - No type found");

    // CASE 0: It is an enumeration of more than one variable
    if(arg_type.equals("set")) {
      String elementsAsString = "";
      String domainClass = "SymbolDomain"; // The default
      String isNumeric = "false";
      String elementType = "";

      for (Enumeration values = argument.enumerateChildren() ; values.hasMoreElements() ; ) {
        IXMLElement element = (IXMLElement)values.nextElement();
        String v = "";

        if(element.getName().equals("value"))
          v = element.getAttribute("name", "ERROR - No value found");
        else
          v = element.getAttribute("value", "ERROR - No value found");
        // Pick up type information, though really only have to do it once. Parser should
        // ensure they are the same, so we assume it here.
        elementType = element.getAttribute("type", "float");

        if(!elementType.equals("bool")) { // if it is a set, it can only have the two values, so we ignore the elements, since we know they must be true and false.
          elementsAsString += v + "$"; // Delimit with $
        }
        //the following *MAY* pleasently rely on the new type checking system
        if(elementType.equals("string")) {
          domainClass = "StringDomain";
        }
        if(elementType.equals("bool")) {
          domainClass = "BoolDomain";
        }
        else if(isNumericPrimitive(elementType)) {
          domainClass = "NumericDomain";
          isNumeric = "true";
        }
      }
      if(elementType.equals("bool")) {
        return domainClass + "(\"" + elementType + "\")";
      }
      return domainClass + "(listFromString(\"" + XMLUtil.escapeQuotes(elementsAsString) + "\","+isNumeric+"), \"" + elementType + "\")";
    } // arg_type.equals("set")

    // CASE 1: It is a singleton, numeric, primitive identifier. Have to support legacy syntax
    // in XML of the form <value name="-16" type="int"/>
    if(isNumericPrimitive(arg_type)) {
      String value = "";

      if(argument.getName().equals("value"))
        value = XMLUtil.getAttribute(argument, "name");
      else
        value = XMLUtil.getAttribute(argument, "value");

      //if(!arg_type.equals(NddlXmlStrings.x_boolean))
      value = value + "," + value;

      return  ModelAccessor.getDomain(arg_type) + "(" + value + ", \"" + arg_type + "\")";
    }

    String type = argument.getAttribute("type", "ERROR - NO 'type'");

    // CASE 2: An interval
    if(arg_type.equals("interval")) {
      String max = XMLUtil.getAttribute(argument,"max");
      String min = XMLUtil.getAttribute(argument,"min");
      return ModelAccessor.getDomain(type) + "("+ min+ ", "+max + ", \"" + type +"\")";
    }

    // CASE 3: A symbol
    if(arg_type.equals("symbol")) {
      String value = argument.getAttribute("value", "ERROR - NO 'value'");
      return "SymbolDomain(LabelStr(\"" + XMLUtil.escapeQuotes(value) + "\"), \"" + type + "\")";
    }

    // CASE 4: A string, boolean or error.
    if(type.equals("string")) {
      String value = argument.getAttribute("name", "ERROR - NO 'value'");
      return "StringDomain(LabelStr(\"" + XMLUtil.escapeQuotes(value) + "\"), \"" + type + "\")";
    }

    if(arg_type.equals(NddlXmlStrings.x_boolean)) {
      String value = argument.getAttribute("name", "ERROR - NO 'value'");
      return "BoolDomain(" + value + ", \"" + type + "\")";
    }

    return "!ERROR. '" + arg_type + "' not a valid constant";
  }

  public static boolean isVariable(String name) {
    boolean result = (isPredefinedVariable(name) || (s_varTypesByName.get(getCurrentScope() + "." + name) != null));
    return result;
  }

  public static boolean isPredefinedVariable(String name) {
    return s_reserved_variables.contains(name);
  }

  /**
   * @brief method to get the value from an atribute.
   */
  public static String getValue(IXMLElement element) {
    String result = "!ERROR";
    if(element.getName().equals(NddlXmlStrings.x_symbol) ||
        element.getName().equals("ident"))
      result = XMLUtil.getAttribute(element, "value");
    else if(element.getName().equals("interval"))
      result = XMLUtil.getAttribute(element, "min") + ", " + XMLUtil.getAttribute(element,"max");
    else
      result = XMLUtil.getAttribute(element, "name");

    return result;
  }

  /**
   * @brief method to get the value from an atribute.
   */
  public static String getValueType(IXMLElement element) {
    if(element.getName().equals(NddlXmlStrings.x_value)) {
      return XMLUtil.getAttribute(element, NddlXmlStrings.x_type);
    }
    if(element.getName().equals(NddlXmlStrings.x_symbol)) {
      return NddlXmlStrings.x_symbol;
    }
    return "!ERROR";
  }

  /**
   * Determine if the given variable name is an object variable in the current scope.
   */
  public static boolean isObjectVariable(String varName) {
    return (getClass(varName) != null);
  }

  /**
   * Obtain the class for a given varName, in current scope of rule instance or predicate.
   * @return null if not of type class, otherwise the class name
   */
  public static String getClass(String varName) {
    // If it is the object variable of the current rule instance, then just strip
    // The Object Class qualifier from the active scope
    if(varName.equals("object"))
      return getCurrentObjectType();

    String type = getTypeForLocalVariable(varName);

    // If we do not get a hit as a local variable, try broader scope.
    if(type == null)
      type = getTypeForScopedVariable(getPredicateScope() + "." + varName);

    if(type == null || !isClass(type))
      type = null;

    assert(DebugMsg.debugMsg("ModelAccessor:getClass","Class for " + varName + " is " + type));
    return type;
  }

  /**
   * Recurse through the stack context for rule instances to look for registered
   * local variables.
   * @return String the type, if found, otherwise null
   */
  private static String getTypeForLocalVariable(String name) {
    List scope = (List) s_currentRule;
    for(int i=0; i < scope.size(); ++i) {
      String currentRule = (String) scope.get(i);
      String type = getTypeForScopedVariable(currentRule + "." + name);
      if(type != null)
        return type;
    }
    return null;
  }

  public static boolean isSymbolicPrimitive(String type) {
    return (type.equals(NddlXmlStrings.x_string) ||
            type.equals(NddlXmlStrings.x_symbol) ||
            type.equals(NddlXmlStrings.x_boolean));
  }

  public static boolean isNumericPrimitive(String type) {
    return (type.equals(NddlXmlStrings.x_int) ||
            type.equals(NddlXmlStrings.x_float));
  }

  public static boolean isInterval(String name) {
    return s_intervals.contains(name) && isEnumeration(name);
  }

  public static boolean isEnumeration(String name) {
    return s_allEnumerations.containsKey(name) && !isClass(name);
  }

  public static String getEnumerationType(IXMLElement enumeration) {
    XMLUtil.checkExpectedNode("enum:typedef", enumeration);
    IXMLElement child = XMLUtil.getSingleChild("set:interval",enumeration);
    if(child.getName().equals("set")) {
      if(!enumeration.hasAttribute("basetype"))
        return "SymbolDomain";
      if(enumeration.getAttribute("basetype", "").equals(NddlXmlStrings.x_string))
        return "StringDomain";
      else
        return "NumericDomain";
    }
    else if(child.getName().equals("interval")) {
      if(enumeration.getAttribute("basetype","").equals(NddlXmlStrings.x_int))
        return "IntervalIntDomain";
      if(enumeration.getAttribute("basetype","").equals(NddlXmlStrings.x_float))
        return "IntervalDomain";
    }
    return null;
  }

  public static void registerEnumeration(String enumeration, String type, boolean isInterval) {
    s_allEnumerations.put(enumeration,type);
    s_intervals.add(enumeration);
  }

  public static boolean isEnumeration(IXMLElement element) {
    return element.getName().equals("enum") || element.getName().equals("typedef");
  }

  public static boolean isInterval(IXMLElement element) {
    return isEnumeration(element) && element.hasChildren() && element.getChildAtIndex(0).getName().equals("interval");
  }

  public static String convertDelimiters(String inputString, String newString) {
    StringBuffer strBuf = new StringBuffer(inputString);
    int index = inputString.indexOf(".");
    if(index >= 0)
      strBuf.replace(index, index + 1, newString);
    return strBuf.toString();
  }

  /**
   * Obtain the suffic for a suring of the form <prefix><delimiter><suffix>
   */
  public static String getSuffix(String delimiter, String inputString) {
    int index = inputString.indexOf(".");
    String suffix = inputString.substring(index +1);
    return suffix;
  }

  /**
   * Need to test if a variable is guarded in order to control if it should be specified or not
   */
  public static boolean isGuarded(String varName, IXMLElement node) {
    if(node.getName().equals("id")) {
      String name = XMLUtil.getAttribute(node, "name");

      if(name.equals(varName) &&
          (node.getParent().getName().equals("if") ||
           node.getParent().getName().equals("equals")))
        return true; /* We are done */
    }

    Vector childNodes = node.getChildren();
    for(int i=0; i < childNodes.size(); ++i) {
      IXMLElement childNode = (IXMLElement) childNodes.elementAt(i);
      if(isGuarded(varName, childNode))
        return true;
    }

    return false;
  }

  /**
   * @see isGuarded
   */
  private static boolean isFilterVariable(String varName, IXMLElement constraintArgNode) {
    IXMLElement parent = (IXMLElement) constraintArgNode.getParent();
    XMLUtil.checkExpectedNode("invoke", parent);
    parent = (IXMLElement) parent.getParent();
    boolean isFilter = (parent.getName().equals("var") && XMLUtil.getAttribute(parent, "name").equals(varName));
    if(isFilter)
      assert(DebugMsg.debugMsg("ModelAccessor","Evaluating for filter variable " + varName + ". IS A FILTER"));
    else
      assert(DebugMsg.debugMsg("ModelAccessor","Evaluating for filter variable " + varName + ". IS NOT A FILTER"));
    return isFilter;
  }

  /**
   * Will register a named subgoal if present.
   * @param slave The <subgoal/> xml element
   */
  public static void registerSlave(IXMLElement slave) {
    XMLUtil.checkExpectedNode("subgoal", slave);

    if(slave.hasChildren()) {
      IXMLElement pred = XMLUtil.getSingleChild("predicateinstance",slave);
      XMLUtil.checkExpectedNode("predicateinstance", pred);
      if(pred.hasAttribute("name")) { // It introduces a named slave to register
        String name = XMLUtil.getAttribute(pred, "name");
        s_slaves.add(getCurrentScope() + "." + name);
        assert(DebugMsg.debugMsg("ModelAccessor:registerSlave","Registering slave " + name));
      }
    }
  }

  public static boolean isSlave(String name) {
    List scope = (List) s_currentRule;
    for(int i=0; i < scope.size(); ++i) {
      String currentScope = (String) scope.get(i);
      if(s_slaves.contains(currentScope + "." + name)) {
        assert(DebugMsg.debugMsg("ModelAccessor:isSlave",name + " is a slave in scope " + currentScope));
        return true;
      }
    }
    assert(DebugMsg.debugMsg("ModelAccessor:isSlave",name + " is not a slave in scope."));
    return false;
  }

  /**
   * Test if a slave is constrained to an object variable
   */
  public static boolean isConstrained(IXMLElement slave) {
    XMLUtil.checkExpectedNode("predicateinstance", slave);
    String type = XMLUtil.getAttribute(slave, "type");
    String prefix = XMLUtil.stripSuffix(type, ".");
    return type.indexOf(".") == -1 || !isClass(prefix);
  }

  /**
   * Obtain the object type for introduction of a new slave
   * @todo Update to handle multi-dot prefix
   */
  public static String getSlaveObjectType(IXMLElement slave) {
    XMLUtil.checkExpectedNode("predicateinstance", slave);
    String type = XMLUtil.getAttribute(slave, "type");

    int index = type.indexOf(".");
    if(index <= 0) // No delimiters at all
      return getCurrentObjectType();

    // Split into prefix and suffix
    String prefix = type.substring(0, type.indexOf("."));
    String suffix = type.substring(type.indexOf(".") + 1, type.length());

    // If prefix is a class, return the class
    if(isClass(prefix))
      return prefix;

    String klass = getClass(prefix);
    while (suffix.indexOf(".") > 0) {
      prefix = suffix.substring(0, suffix.indexOf("."));
      suffix = suffix.substring(suffix.indexOf(".") + 1, suffix.length());
      klass = getTypeForScopedVariable(klass + "." + prefix);
    }

    assert(DebugMsg.debugMsg("ModelAccessor","ModelAccessor.getSlaveObjectType CLASS for " + type + " is " + klass));
    return klass;
  }

  /**
   * Determine if the current rule node requires an impicit
   * guard which has not already been accounted for in the rule.
   * @param node The current XML node in the rule structure
   * @param guards A ':' delimited set of existing guards already specified at this point
   * @return true If the current node implicitly or explicitly introduces a guard
   * @see getOutStandingGuards
   */
  public static boolean hasImplicitGuard(IXMLElement node, Set guards) {
    boolean b = !getOutstandingGuards(node, guards).isEmpty();
    assert(DebugMsg.debugMsg("ModelAccessor","RuleWriter:requiresGuard returns " + b));
    return (b);
  }

  public static boolean hasExplicitGuard(IXMLElement node) {
    return node.getName().equals("if");
  }

  public static String getExplicitGuard(IXMLElement node) {
    XMLUtil.checkExpectedNode( "if", node);
    // If child is equals
    IXMLElement id = (IXMLElement) node.getChildAtIndex(0);
    if(id.getName().matches("^(n)?equals$"))
      id = id.getChildAtIndex(0);
    String idName = XMLUtil.getAttribute(id, "id", "name");
    return idName;
  }

  /**
   * Helper method
   * @see getOutStandingGuards
   */
  private static Set addObjectGuardIfNeeded(String idName, Set currentGuards) {
    Set newGuards = new HashSet(currentGuards);
    // Ignore if the id is not of the pattern <prefix>.<suffix>
    int delimiterPosition = idName.indexOf(".");
    if(delimiterPosition >= 0) {
      String guard = idName.substring(0, delimiterPosition);

      // Quit if guard is neither a slave or an oblect variable
      if(!isSlave(guard) && !isObjectVariable(guard)) {
        assert(DebugMsg.debugMsg("ModelAccessor:addObjectGuardIfNeeded","Neither a slave or object variable."));
        return newGuards;
      }

      // If a slave, then it must have an extra delimited field to be acceptable
      if(isSlave(guard)) {
        assert(DebugMsg.debugMsg("ModelAccessor:addObjectGuardIfNeeded","Testing a slave."));
        String suffix = idName.substring(delimiterPosition+1, idName.length());
        delimiterPosition = suffix.indexOf(".");
        if(delimiterPosition < 0) { // Not an implied guard
          assert(DebugMsg.debugMsg("ModelAccessor:addObjectGuardIfNeeded","Slave has no outstanding guards."));
          return newGuards;
        }
        else{
          assert(DebugMsg.debugMsg("ModelAccessor:addObjectGuardIfNeeded","Slave guarded by " + guard));
          guard = guard + "." + suffix.substring(0, delimiterPosition);
        }
      }

      if(!currentGuards.contains(guard)) // Then it is not accounted for
        newGuards.add(guard);
    }

    assert(DebugMsg.debugMsg("ModelAccessor:addObjectGuardIfNeeded","Old Guards: " + currentGuards + "; New Guards = " + newGuards));
    return newGuards;
  }

  /**
   * Obtain a ':' delimited string for any new guard variables in the constraint
   * <token>.<var> => NO GUARD
   * <token>.<var>.<var> => GUARD
   * <var>.<var>
   */
  public static Set getOutstandingGuards(IXMLElement node, Set guards) {
    Set newGuards = new HashSet();

    // Filter out nodes that cannot require a guard
    if(!s_guardableNodes.contains(node.getName())) {
      return newGuards;
    }

    if(false) { // DEPRECATED (node.getName().equals("invoke")) // CASE 0: It is a constraint
      // Iterate over all the arguments
      Vector ids = node.getChildrenNamed("id");
      assert(DebugMsg.debugMsg("ModelAccessor:getOutStandingGuards","num ids " + ids.size()));
      for(int j = 0; j < ids.size(); ++j) {
        IXMLElement id = (IXMLElement) ids.elementAt(j);
        String idName = XMLUtil.getAttribute(id, "name");
        newGuards = addObjectGuardIfNeeded(idName, newGuards);
      }
    }
    else if(node.getName().equals("subgoal") && node.getChildrenNamed("predicateinstance").size()==1) { // CASE 1: A slave on multi-level variable
      IXMLElement predicate = (IXMLElement) node.getChildAtIndex(0);
      String type = XMLUtil.getAttribute(predicate, "type");
      // If more than one level of indirection on the type then it implies
      // a guarded object variable. There will only be one.
      int index = type.indexOf(".");
      if(index > 0) {
        String suffix = type.substring(index+1, type.length());
        if(suffix.indexOf(".") > 0)
          newGuards = addObjectGuardIfNeeded(type.substring(0, index), newGuards);
        assert(DebugMsg.debugMsg("ModelAccessor:getOutStandingGuards","SLAVE GUARD TEST: Current guards = "+guards+"; New guards for "+ type +" = " + newGuards));
      }
    }
    else if(node.getName().equals("if")) {
      String explicitGuard = getExplicitGuard(node);
      int index = explicitGuard.indexOf(".");
      if(index >0)
        newGuards = addObjectGuardIfNeeded(explicitGuard.substring(0, index), newGuards);
    }
    assert(DebugMsg.debugMsg("ModelAccessor:getOutStandingGuards","New Guards " + newGuards + " returned for existing guards " + guards));
    return newGuards;
  }

  public static boolean isSlaveRelation(String relation) {
    return s_slave_relations.contains(relation);
  }

  public static Set getCustomIncludes() {
    return s_usedCustomIncludes;//s_customIncludes;
  }

  /**
   * Initializes all configuration information. must be called before ModelAccessor is used, wise to do
   * statically from whichever main is executed.
   */
  public static void init() {

    assert(DebugMsg.debugMsg("ModelAccessor:init", "Initializing from directory "+s_directory));
    // reset, init may be called again for some reason.
    s_customSearchPath.clear();
    s_customClassesByNddlName.clear();
    s_customIncludes.clear();
    s_usedCustomIncludes.clear();
    s_customIncludesByCppName.clear();

    // If s_cfgFilename is available in the directory from which this
    // program is run, then use that file to load properties
    try{
      // search for NDDL.cfg locally
      File cfgFile = new File(s_directory, s_cfgFilename);
      if(!cfgFile.exists())
        cfgFile = new File(System.getProperty("user.dir"), s_cfgFilename);
      if(!s_cfgExact) {
        // if we're allowed to, search in parent directories.
        while(!cfgFile.exists() && cfgFile.getParentFile() != null) {
          cfgFile = new File(cfgFile.getParentFile().getParentFile(), s_cfgFilename);
        }
      }
      if(!cfgFile.exists() && s_plasmaHome != null) {
        // if all else fails, attempt to look in $PLASMA_HOME/config (ignore any custom s_cfgFilename)
        cfgFile = new File(s_plasmaHome+"/config", DEFAULT_CFG);
      }
      if(!cfgFile.exists())
        // we're done trying, throw an error.
        throw new FileNotFoundException("Couldn't find "+s_cfgFilename);

      assert(DebugMsg.debugMsg("ModelAccessor:init", "Loading Compiler configuration data from file "+cfgFile));
      IXMLParser parser = XMLParserFactory.createDefaultXMLParser();
      IXMLReader reader = new StdXMLReader(new BufferedReader(new FileReader(cfgFile)));
      parser.setReader(reader);
      IXMLElement root =  (IXMLElement) parser.parse();
      XMLUtil.checkExpectedNode("configuration", root);
      Vector bindings = root.getChildrenNamed("binding");
      for(int i=0; i < bindings.size(); ++i) {
        IXMLElement binding = (IXMLElement) bindings.elementAt(i);
        String nddl = NddlUtil.expandEnvVariables(XMLUtil.getAttribute(binding, "nddl"));
        String cpp = NddlUtil.expandEnvVariables(XMLUtil.getAttribute(binding, "cpp"));
        s_customClassesByNddlName.put(nddl, cpp);
        if(binding.hasAttribute("include")) {
          String source = NddlUtil.expandEnvVariables(XMLUtil.getAttribute(binding, "include"));
          s_customIncludes.add(source);
          s_customIncludesByCppName.put(cpp, source);
        }
      }
      // process include path
      Vector includes = root.getChildrenNamed("include");
      for(Iterator it = includes.iterator(); it.hasNext();) {
        IXMLElement path = (IXMLElement) it.next();
        String pathAsString = XMLUtil.getAttribute(path, "path");
        // record custom search path for nddl files.

        String[]paths = pathAsString.split(";");
        for(int i=0; i < paths.length; ++i) {
          String aPath=NddlUtil.expandEnvVariables(paths[i]);   
          if(new File(aPath).isAbsolute())
            addSearchPath(aPath);
          else
            addSearchPath(cfgFile.getParent() + File.separator + aPath);
        }
      }


      // process constraint registration
      Vector constraints = root.getChildrenNamed("constraint");
      for(int i=0; i < constraints.size(); ++i) {
        IXMLElement constraint = (IXMLElement)constraints.get(i);
        String name = NddlUtil.expandEnvVariables(constraint.getAttribute("name", null));
        String cpp =  NddlUtil.expandEnvVariables(constraint.getAttribute("cpp", null));
        if(name == null || cpp == null) {
          System.err.println("NddlCompiler Warning: constraint registrations must contain both a \"name\" and \"cpp\" attribute.");
          continue;
        }
        String propagator =  NddlUtil.expandEnvVariables(constraint.getAttribute("propagator", "Default"));
        SchemaWriter.addConstraintRegistration("REGISTER_CONSTRAINT(" +cpp +", \"" + name + "\", \"" + propagator +"\")");
      }
    }
    catch(FileNotFoundException e) {
      assert(DebugMsg.debugMsg("ModelAccessor:init", "File not found: "+e.getMessage()));
      s_customClassesByNddlName.put("Object", "Object");
      s_customClassesByNddlName.put("Timeline", "Timeline");
//       s_customClassesByNddlName.put("Resource", "NddlResource");
//       s_customClassesByNddlName.put("Resource.change", "NddlResource::change");
    }
    catch(Exception e) {
      e.printStackTrace();
      System.exit(-1);
    }
  }

  /**
   * If file "parent + filename" exists, then return it,
   * otherwise search the search path for filename and return it.
   *
   * If the "parent + filename" or just "filename" does not exist and is not found in the
   * search path, "path + filename" is returned. The caller must be prepared to
   * handle a file that does not exist.
   */
  public static final File generateIncludeFileName(final String parent, final String filename) {
    File returnFile = null;
    List searchPath = new ArrayList(3 + s_customSearchPath.size());
    searchPath.add(parent);
    searchPath.add(s_directory);
    searchPath.addAll(s_customSearchPath);
    // As a last resort, ignore user set directory
    searchPath.add(System.getProperty("user.dir"));

    for(int i=0; i < searchPath.size(); ++i) {
      String p = (String) searchPath.get(i);
      if(p == null)
        continue;
      returnFile = new File(p, filename);
      assert(DebugMsg.debugMsg("ModelAccessor:includeSearch", "Testing for: " + returnFile));
      if(returnFile.canRead())
        return returnFile;
    }
    return null;
  }
}
