#include "../../NDDL/core/PlannerConfig.nddl"
#include "../../NDDL/core/Plasma.nddl"

class Target {
 string m_name;
 int m_x;
 int m_y;
 int m_z;
 int m_size;
 float m_priority;
 bool m_mandatory;

 Target(string name, int x, int y, int z, int size, float priority) {
  m_name = name;
  m_x = x;
  m_y = y;
  m_z = z;
  m_size = size;
  m_priority = priority;
  m_mandatory = false;
 }

 Target(string name, int x, int y, int z, int size, float priority, bool mandatory) {
  m_name = name;
  m_x = x;
  m_y = y;
  m_z = z;
  m_size = size;
  m_priority = priority;
  m_mandatory = mandatory;
 }
}

class Satellite {
 Antenna m_antenna;
 Memory m_memory;

 Satellite () {
  m_antenna = new Antenna (10000, 0, 10000);
  m_memory = new Memory (100000, 10, 100000);
 }

 predicate TakeImg {
   Target m_target;
   int m_duration;
   eq(duration, m_duration);
 }

 predicate Slew {
   Target m_from;
   Target m_to;
   int m_rate;
 }

 predicate HaveImg {
   Target m_target;   
 }

 predicate Pointing {
   Target m_target;
 }

 predicate Transmit {
   GroundStation m_station;
   Target m_data;
 }
}

class GroundStation extends Object {
  Storage m_disk;

 GroundStation () {
   m_disk = new Storage (10000000, 1000, 10000000);
 }

 predicate Receive {
   Target m_data;
 }
}

class Antenna extends Resource { 
  Antenna(float initCap, float llmin, float llmax) {
    super(initCap, llmin, llmax);
  }
}

class Memory extends Resource {
 Memory(float initCap, float llmin, float llmax) {
    super(initCap, llmin, llmax);
  }

}

// Storage can only be consumed
class Storage extends Resource {
  Storage(float initCap, float llmin, float llmax) {
    super(initCap, llmin, llmax, 0, 0, MINUS_INFINITY, MINUS_INFINITY);
  }
}

Satellite::TakeImg {
  met_by(object.Pointing p);
  starts(Memory.change tx);
  eq(tx.quantity,m_target.m_size);
  eq(duration,m_target.m_size);
}

// doesn't calculate exact, but rather, linear distance as a simplification
Satellite::Slew {
  met_by(object.Pointing pfrom);
  meets(object.Pointing pto);
  eq(pfrom.m_target,m_from);
  eq(pto.m_target,m_to);
  int dx, dy, dz;
// workaround while multiple . is not being supported in the NDDL compiler
/*
  Target tgt;
  eq(pto.m_target,tgt);
  Target fgt;
  eq(pfrom.m_target,fgt);
  addeq(dx,fgt.m_x,tgt.m_x);
  addeq(dy,fgt.m_y,tgt.m_y);
  addeq(dz,fgt.m_z,tgt.m_z);
*/
  addeq(dx,pfrom.m_target.m_x,pto.m_target.m_x);
  addeq(dy,pfrom.m_target.m_y,pto.m_target.m_y);
  addeq(dz,pfrom.m_target.m_z,pto.m_target.m_z);
  addmuleq(dz,dy,dz,m_rate,duration);
}

Satellite::HaveImg {
  met_by(object.TakeImg t);
}

Satellite::Pointing {
  bool move;
  if (move == true) {
    meets(Satellite.Slew s);
    eq(s.object,object);
    eq(s.m_from, m_target);
  }
  if (move == false) {
    meets(Satellite.TakeImg ti);
    eq(ti.object,object);
    eq(ti.m_target, m_target);
  }
  met_by(Satellite.Slew s1);
  eq(s1.object,object);
  eq(s1.m_to, m_target);
}

Satellite::Transmit {
  eq(duration,m_data.m_size);
  met_by(object.HaveImg h);
  starts(Antenna.change tx1);
  eq(tx1.quantity, m_data.m_size);
  contains(m_station.Receive r);
  eq(r.duration,duration); 
}

GroundStation::Receive {
//  GroundStation g;
//  eq(g,object);
//  starts(g.m_disk.change tx2);
  starts(object.m_disk.change tx2);
/*
  Storage d;
  eq(d,g.m_disk);
  starts(d.change tx2);
  eq(tx2.quantity, m_data.m_size);
*/
// this is what we'd like to write
//  starts(Storage.change tx2);
//  eq(tx2.object,object.m_disk);
   eq(tx2.quantity, m_data.m_size);
}

// create  objects
PlannerConfig world = new PlannerConfig(0,100,5000);
Target target1 = new Target("target1",10,10,10,100,95.0);
Target target2 = new Target("target2",25,25,25,25,90.0);
Target target3 = new Target("target3",50,50,50,80,84.0);
Satellite satellite1 = new Satellite();
GroundStation ground1 = new GroundStation();
close();

// initial tokens
goal(Satellite.Pointing p);
eq(p.m_target, target1);
p.start.specify(0);
p.activate();

rejectable(GroundStation.Receive r1);
eq(r1.m_data, target1);
eq(r1.object,ground1);

rejectable(GroundStation.Receive r2);
eq(r2.m_data, target2);
eq(r2.object,ground1);
