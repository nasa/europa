#include "../../NDDL/core/Plasma.nddl"
#include "../../NDDL/core/PlannerConfig.nddl"

// Very small subset of the IPC-3 Rover Domain translated by hand from NDDL to PDDL to 
// verify state-based encoding is possible in PLASMA.
// July 12, 2005

// :types from PDDL domain. 
class Rover {}
class Waypoint {}

// : static predicates.

class Can_Traverse {
  Rover x;
  Waypoint y;
  Waypoint z;

  Can_Travserse(Rover _x, Waypoint _y, Waypoint _z) {
    x = _x;
    y = _y;
    z = _z;
  }
}
 
class Visible {
  Waypoint y;
  Waypoint z;

  Visible(Waypoint _y, Waypoint _z) {
    y = _y;
    z = _z;
  }
}

class At_and_not_at_mutex extends UnaryResource {
   Rover rover;   
   Waypoint waypoint;
  
   At_and_not_at_mutex (Rover _rover, Waypoint _waypoint) {
     rover = _rover;
     waypoint = _waypoint;
   }

   predicate use {
      Rover rover;
      Waypoint waypoint;    
   }
}

class At_and_navigate_mutex extends UnaryResource {
  Rover rover;
  Waypoint waypoint;

  At_and_navigate_mutex (Rover _rover, Waypoint _waypoint) {
    rover = _rover;
    waypoint = _waypoint;
  }

  predicate use {
     Rover rover;
     Waypoint waypoint;
  }
}

class Not_at_and_navigate_mutex extends UnaryResource {
  Rover rover;
  Waypoint waypoint;

  Not_at_and_navigate_mutex (Rover _rover, Waypoint _waypoint) {
    rover = _rover;
    waypoint = _waypoint;
  }

  predicate use {
     Rover rover;
     Waypoint waypoint;
  }
}


// Operators and state predicates

class Domain extends Object {
 
   // Operator Navigate.
   predicate navigate { 
      Rover x; 
      Waypoint y; 
      Waypoint z;
   }

   // state predicate at
   predicate at {
     Rover x;
     Waypoint y;
     eq(duration, 1);
   }

   // state predicate not_at
   predicate not_at {
      Rover x;
      Waypoint y;
      eq(duration, 1);
   }
}

Domain::navigate{
   eq(duration, [1 1]);
   // conditions on static predicates    
    Can_Traverse route : {
      eq(route.x, x);
      eq(route.y, y);
      eq(route.z, z);
    };

    Visible vis : {
       eq(vis.y, y);
       eq(vis.z, z);
    };

   // ** preconditions
   met_by (Domain.at previousPosition);
   eq(previousPosition.x, x);
   eq(previousPosition.y, y);

   // ** effects  
   meets (Domain.at newPosition);
   eq(newPosition.x, x);
   eq(newPosition.y, z);

   meets (Domain.not_at not_previousPosition);
   eq(not_previousPosition.x, x);
   eq(not_previousPosition.y, y); 

   // ** Mutex Constraints   
   //cannot be at while navigating.
   contained_by(At_and_navigate_mutex.use mutex_constraint);
   eq(mutex_constraint.rover, x);
   eq(mutex_constraint.waypoint, y);

   At_and_navigate_mutex m: {
       eq(m.rover, x);
       eq(m.waypoint, y);
    };
    eq(mutex_constraint.object, m);

    // cannot be not(at) while navigating
    contained_by(Not_at_and_navigate_mutex.use mutex_constraint2);
    eq(mutex_constraint2.rover, x);
    eq(mutex_constraint2.waypoint, y);

    Not_at_and_navigate_mutex m2: {
       eq(m2.rover, x);
       eq(m2.waypoint, y);
    };
    eq(mutex_constraint2.object, m2);
}

Domain::at {
    eq(duration, [1 1]);

    // **  Preconditions
    met_by (Domain.navigate prevMove);
    eq(prevMove.x, x);
    eq(prevMove.z, y);
   
    // ** Effects
    meets(Domain.navigate nextMove);
    eq(nextMove.x, x);
    eq(nextMove.y, y);

    // ** Mutex Relationships
    // cannot be at(rover, loc) and not(at(rov, loc))
    contained_by(At_and_not_at_mutex.use mutex_constraint);
    eq(mutex_constraint.rover, x);
    eq(mutex_constraint.waypoint, y);

    At_and_not_at_mutex m: {
      eq(m.rover, x);
      eq(m.waypoint, y);
    };
    eq(mutex_constraint.object, m);
   
    // cannot be at and navigating
    contained_by(At_and_navigate_mutex.use mutex_constraint2);
    eq(mutex_constraint2.rover, x);
    eq(mutex_constraint2.waypoint, y);

    At_and_navigate_mutex m2: {
       eq(m2.rover, x);
       eq(m2.waypoint, y);
    };
    eq(mutex_constraint2.object, m2);
}

Domain::not_at {
    eq(duration, [1 1]);
    // ** Precondtions
    // none?

    // ** Effects
    // none?
 
    // ** Mutex Relationships
    // mutex relationship with at
    contained_by(At_and_not_at_mutex.use mutex_constraint);
    eq(mutex_constraint.rover, x);
    eq(mutex_constraint.waypoint, y);

    At_and_not_at_mutex m: {
      eq(m.rover, x);
      eq(m.waypoint, y);
    };
    eq(mutex_constraint.object, m);

    // cannot be not at while navigating
    contained_by(Not_at_and_navigate_mutex.use mutex_constraint2);
    eq(mutex_constraint2.rover, x);
    eq(mutex_constraint2.waypoint, y);

    Not_at_and_navigate_mutex m2: {
       eq(m2.rover, x);
       eq(m2.waypoint, y);
    };
    eq(mutex_constraint2.object, m2);

}

